# MySQL
1. MySQL 支持哪些存储引擎
   MySQL 支持多种存储引擎，`show engines`查看，默认`innoDB`
   MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。
   
2. MySQL 索引
   1. 什么是索引
      索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。
   2. 索引存储了什么
      索引实际上是一种数据结构，存储了表格中某些列的值与行所在位置的对应关系。具体来说，索引存储了以下两种信息：
      1. 索引列的值
      2. 行所在位置的指针
   3. 索引有哪些实现方式
      索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。
   4. 索引的优缺点
      优点：
      - 索引可以加快数据检索速度
      - 通过创建唯一索引，可以保证表中每一行数据的唯一性
      缺点：
      - 创建和维护索引有性能消耗，在对数据进行增删改时会同时更新索引，降低SQL执行效率
      - 索引需要物理文件存储，会消耗空间
   5. 索引一定能提高查询性能吗？
      大多数情况下是的，但数据量小的情况下一般提升不明显
   6. 使用索引的注意事项
      - 选择合适的字段创建索引
        - 索引字段不为NULL
        - 对频繁查询的字段创建索引
        - 被作为条件查询的字段
        - 频繁需要排序的字段
        - 被经常频繁用于连接的字段
      - 频繁更新的字段应慎重创建索引
      - 限制每张表上的索引数量
        - 建议单表不超过5个
      - 尽可能建立联合索引而不是单列索引
        - 多字段在一个索引上可以节约空间
      - 避免冗余索引
      - 字符串类型字段使用前缀索引
      - 避免索引失效
        - 创建了组合索引，但未遵循最左匹配原则
        - 在索引列上进行转换操作
        - 以`%`开头的`like`查询
   7. 怎么分析一条语句是否走索引查询
      使用`EXPLAIN`命令分析SQL的执行计划，执行计划指一条SQL经过 MySQL查询优化器的优化后具体的执行方式
   8. 一条SQL命中索引时的查询过程
      1. 解析SQL语句：数据库引擎首先会解析SQL语句，分析查询语句的结构和语义，以确定需要查询的表格、字段、条件等信息。
      2. 选择索引：根据查询语句中涉及到的表格、字段和条件等信息，数据库引擎会选择最适合的索引来加速查询。一般来说，数据库会根据查询条件的复杂度和索引的覆盖程度等因素来选择索引。
      3. 加载索引：数据库引擎会加载选择的索引，以获取索引的元数据和数据块等信息。如果索引被缓存在内存中，那么加载索引的过程会非常快速。
      4. 执行查询：数据库引擎会利用索引进行查询，根据索引的数据结构和查询条件来定位符合条件的数据行。由于索引的数据结构通常是树形结构（如B树或B+树），所以查询的时间复杂度是O(log n)级别的。
      5. 返回结果：当查询结束后，数据库引擎会将查询结果返回给应用程序。如果查询中使用了聚合函数（如SUM、AVG等），那么数据库引擎会在索引上进行聚合操作，从而进一步提高查询效率。
   9. 假如我在user表上有一个关于name列的索引，那么语句`select name from user`会被索引优化吗，是怎么优化的
      会优化，即使是没有条件的全量查询，在只查询索引列是，数据库会使用索引来避免全表扫描
    
3. MySQL 三大日志
   1. 什么是 “二进制日志 binlog 归档日志”，有什么作用
      binlog 是逻辑日志，记录内容是语句的原始逻辑
      只要发生了表数据更新，都会产生 binlog
      MySQL 的数据备份、主备、主主、主从都离不开 binlog，依靠 binlog 进行数据同步，保证数据的一致性


4. MySQL 事务隔离级别
   1. 有哪些事务隔离级别
      1. 读取未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
      2. 读取已提交：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
      3. 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
      4. 可串行化：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
   2. 什么是脏读、不可重复读、幻读
      1. 脏读：当一个事务读取了另一个事务未提交的数据时，可能发生，因为一旦另一个事务回滚，那么这个事务读取到的值就是错的，会导致数据不一致性的问题
      2. 不可重复读：当一个事务多次读取同一数据时，由于其他事务对该数据进行了修改或删除，导致读取到的数据不一致，就会发生不可重复读。
      3. 幻读：当一个事务读取了另一个事务未提交的插入或删除操作，导致读取到的数据集合发生了变化，就会发生幻读。
   3. 并发事务的控制方式有哪些
      锁 和 MVCC（多版本并发控制）
      - 锁：提供共享锁和拍他锁对应读写操作


5. 自增主键一定是连续的吗，为什么
   不一定，以下场景会出现：
   - 当设置自增步长不为1时
   - 事务回滚或其他错误时，自增值不会回退
   - 批量插入，申请的自增ID可能存在用不完的情况，那么浪费的id就被跳过了
   
6. 数据库优化手段有哪些？
   从以下几个方面：
   - 表设计：字段类型、分页、不要外键与级联
   - SQL语句：不要全量查询、聚合查询
   - 正确使用索引

7. 什么是读写分离？
   读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。提高并发
   1. 读写分离会带来什么问题？怎么解决
      主从库之间存在数据延迟（主从同步延迟）
      优化网络连接：确保主从数据库之间的网络连接稳定并且带宽充足。可以通过升级网络设备、增加带宽等方式来优化网络连接。
      优化数据库负载：通过优化主数据库的负载，例如增加主数据库的节点数、使用读写分离等方式，可以减轻主数据库的负载，从而缓解主从同步延迟的问题。
      优化从数据库性能：通过优化从数据库的性能，例如升级硬件、优化数据库配置等方式，可以提升从数据库的处理能力，从而缩短主从同步延迟的时间。
      使用异步复制：如果数据一致性不是非常重要，可以使用异步复制来提高主从同步的性能。异步复制允许从数据库稍后接收到主数据库的更新数据，从而减少主从同步延迟的影响。
      使用双主架构：如果数据一致性非常重要，可以使用双主架构来提高主从同步的性能和可靠性。双主架构可以让主数据库相互之间进行同步，从而减少主从同步延迟的时间，并提高主从同步的容错能力。
   2. 怎么实现读写分离？
      主要实现3个方面：
      1. 部署多节点
      2. 读写请求转发
      3. 主从复制（数据同步）
   3. 怎么实现主从复制，保证数据同步
      binlog 记录了数据库所有的数据变化，因此有了主库的 binlog 就能同步主库的数据，所以建立一个 binlog 的同步服务让从库去执行主库的 binlog 即可

8. 分库分表
   1. 什么是分库分表？
      分库分表解决存储压力
      分库：将数据库中的数据分散到不同的数据库上，垂直水平
      分表：对表的数据拆分
   2. 什么情况下要分
      1. 单表数据在千万级别以上且数据库读写慢
      2. 数据库占用空间过大，导致备份不便
      3. 应用并发量大，加上数据量大，导致性能降低
   3. 会带来哪些问题？
      - 无法使用`join`
      - 事务问题
      - 分布式id
      - 其他
      


   
# redis
1. redis 为什么快
   1. 在内存上访问
   2. 有一套高效的事件处理模型：单线程事件循环、IO多路复用
   3. 优化了数据结构
   
2. redis怎么实现分布式锁
   使用`SETNE`实现互斥，当 key 不存在时设置值，存在时什么都不做，通过`DEL`释放锁
   todo
  
3. redis 数据结构
   todo
4. 怎么实现持久化
   - 快照 RDB
   - 只追加文件 AOF
   - RDB AOF 混合持久化

   1. 什么是快照
      获取某个时间点内存副本
   2. 创建快照时会阻塞主线程吗
      有两个命令生成快照：
      - save：同步保存，会阻塞
      - bgsave： 后台保存，会创建子进程，由子进程处理，不会阻塞主线程
   3. 什么是AOF
      开启 AOF 后，每当执行数据修改的操作时，redis 就会将其命令写入 AOF 缓冲区，然后再写入 AOF 文件（此时还在内核缓冲区，未同步到磁盘），最后根据持久化方式的配置决定何时同步到磁盘中
   4. AOF 的步骤是什么
      1. 命令追加：所有的写命令都会追加到 AOF 缓冲区中
      2. 写入文件：AOF 缓冲写到 AOF 文件
      3. 文件同步：文件向磁盘同步
      4. 文件重写：定期重写，压缩
      5. 重启加载：数据恢复
   5. 怎么选择两种持久化方式
      如果数据丢失一点也没什么影响，可以选择 RDB

5. Redis 线程模型什么样的
   单线程模型
   1. 单线程怎么处理大量的请求呢？
      通过 IO多路复用来舰艇来自客户端的大量连接（坚挺多个socket），这样不需要创建额外的线程监听客户端连接，降低了资源消耗
   2. 为什么不使用多线程
      Redis 的主要性能问题在内存和网络，不在CPU，同时多线程还会造成并发死锁和线程切换的问题，反而影响性能6. 

6. Redis 怎么判断数据是否过期呢
   Redis 维护一个 过期字典 来保存数据的过期时间
   1. 过期数据怎么删除
      1. 惰性删除：只有在访问到 key 的时候才进行过期检查，这样性能好，但可能存在很多过期的 key 没有删除
      2. 定期删除：每隔一段时间抽取一批 key 进行检查和删除，对内存友好
   2. 内存淘汰机制是什么，（Redis 作为缓存只能保存少量数据，怎么保证这些数据是热点数据呢）
      6种数据淘汰机制
      - volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。
      - volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。
      - volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。
      - allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
      - allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。
      - no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！
      - volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。
      - allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。

   
7. 什么是 Redis 内存碎片
   连续的内存空间内没有被使用的部分称为碎片
   在 Redis 的场景下，当 Redis 申请内存时会得到比实际使用更大的内存；当删除某个数据时，不会轻易的释放内存给操作系统
   1. 怎么查看内存碎片信息
      使用`info memory`
   2. 怎么清理内存碎片
      配置 Redis 自动清理

8. Redis 常见的阻塞原因
   1. 使用了时间复杂度高的命令
   2. save 命令
   3. AOF 执行时
   4. 大Key：单线程处理大Key时比较耗时，在网络传输时还会造成网络阻塞，在删除大Key时还会阻塞工作线程

9.  什么是Redis事务
   Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。
   除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。因此，Redis 事务是不建议在日常开发中使用的。
   1. 如何使用 Redis 事务？
      `MULTI`命令后传入多条命令，不会立即执行，而是放到队列里，当调用了`EXEC`命令后，就会执行所有命令
   2. Redis  事务满足原子性吗？
      不满足，因为一个事务中的命令就算有出错的，其他正确的也正常执行，而且不支持回滚
   3. 支持持久性吗？
      支持，RDB、AOF和组合的方式

10. 怎么优化 Redis 性能
   1. 使用原生批量操作命令减少网络请求
   2. 大量 key 集中过期问题
      1. 设置随机过期时间
      2. 开启 lazy-free （惰性删除/延迟释放）
   3. 处理daKey
      1. 分割（可能需要修改业务代码、不推荐）
      2. 手动清理
      3. 采用合适的数据结构
      4. 开启 lazy-free
   4. 处理 hotkey
      1. 一个key的访问频率明显过高，可看作 hot
      2. hotkey 会占用过多 CPU 和带宽，造成性能问题
      3. 读写分离
      4. 使用 Redis 集群，多节点分担多个 hotkey 的压力
      5. 二级缓存：将 hotkey 存放一份到应用内存中

11. redis 常见问题
   1.  什么是缓存穿透
       有大量的请求的 key 是不存在的，这样就会越过缓存，直接到达数据库，压力陡增
       1. 怎么解决
          1. 缓存无效key：当收到这样的请求时，就设置一个有过期时间的 key，但如果无效 key 数量非常多这样并不能解决问题
          2. 布隆过滤器：过滤掉不存在的 key
   2. 什么是缓存击穿
      对于 热点数据 来说，当缓存中的 key 失效，那么热点数据的key会有大量请求直接到达数据库，压力陡增
      1. 怎么解决
         1. 设置热点数据的缓存过期时间
         2. 根据业务提前设置热点数据缓存
   3. 什么是缓存雪崩
      短期内缓存大面积失效，请求直接到达服务器
   4. 怎么保证缓存与数据库的一致性
      [缓存和数据库一致性问题，看这篇就够了](https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd)



