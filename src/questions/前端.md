## 语言

1. JS 中有哪些数据类型？
   js 中的数据类型分为基本类型和引用类型
   基本类型包括：string、number、boolean、null、symbol、undefined
   引用类型包括：object 和其他的 object 封装

   ❓怎么判断数据类型呢？
   js 提供了 typeof 和 instanceof 两个操作符
   typeof 会返回变量的类型值，只会返回 `undefined boolean number string symbol function object` 7个值
   但是 typeof 会有一些缺陷，例如在对 null 执行该操作时会返回 object，这是由于JavaScript在底层使用的是32位的值来存储数据类型信息和实际数据，其中，对象类型的值的低3位为0，而null的表示形式是全0的32位二进制数（在JavaScript中，null的表示形式为0x00）。因此，在判断null类型时，typeof操作符会将其误判为对象类型。
   instanceof 会判断一个值是否是一个对象的实例，他通过查找对象原型链上是否有给定的构造函数原型来确定是否是实例关系
   还可以使用 toString 方法，他会返回对象类型和其他信息，只能判断基本类型的包装对象和内置对象,其他时候会返回 `[object object]`

   ❓基本类型和引用类型有什么区别呢？
   存储位置：堆栈
   复制方式：直接复制值与复制地址，涉及到深浅拷贝的问题
   比较方式：值比较与引用比较
   可变性：基本类型虽然可变，但实际上是新建了一个值（todo）

   ❓什么是堆栈内存呢？
   栈是在运行时创建的，函数被调用时会创建一个栈帧，并推入栈中，调用结束后出栈，函数运行过程中声明的基本类型会直接在栈中创建，并在运行结束时自动销毁回收
   堆用来存储程序运行过程中产生的引用数据，他不会自动释放空间，需要GC机制处理
   除此之外，还存在代码区（存储代码）、静态区（用于存储常量、静态变量、函数等，会在程序运行期间一直存在，不会被销毁）
2. 什么是闭包？
   一个函数可以访问其外部函数作用域中的变量和参数，即使外部函数已经执行完毕并返回，该函数仍然可以访问这些变量和参数。换句话说，闭包是由函数和与其相关的引用环境组合而成的实体，可以捕获并存储外部函数的变量和参数。
   有一点要注意，在闭包的情况下，引用的数据不管是基本类型还是引用类型，都是存放在堆中的，这是因为外部函数执行结束后栈内存会被回收，所以只能存在堆里，这会在一些情况下造成内存问题
3. 数组和对象是怎么实现的？
4. 原型和原型莲是什么？
   原型是 object 的一个属性，他的存在是为了弥补js在面向对象时继承的问题。当一个对象被实例化时，他就获得一个指向其构造函数的属性，这个构造函数的所有实例可以通过这个原型属性分享一些属性。
   其中函数对象有 `prototype`，普通对象只有 `__proto__`
5. 怎么创建一个变量？
   js 提供了 `var let const`关键字来声明变量
   var 是旧版本的方式，他创建的对象会存在函数作用域里，如果是在顶级作用域创建，会附加到全局对象上，同时还存在变量提升的问题，这是js引擎的优化或者说是预处理，在代码解析后，会将变量的声明提前到代码运行的开始，函数提升也是类似的道理
   let 是为了适应现代化语言的特点而设计的，let 使得变量的声明和使用更规范，必须先声明再使用，不可重复声明，且声明的变量会存在块级作用域里，在顶层作用域里声明时，会提供一个独立作用域附加到作用域链上，而不是成为顶层对象的属性
   const 与 let 类似，只不过要在定义时赋值，且不可修改最外层定义

   ❓什么是作用域和作用域链？
   作用域也叫做上下文 `context or scope`，是指变量和函数的可访问范围。js 中的作用域是“词法作用域”，也就是静态作用域，代码写完就决定了每部分的作用域，不会在执行过程中改变。
   js 代码在执行过程中会在函数和代码块时创建新作用域，这些作用域会形成一个链状结构，顶层是当前的块级作用域，底层是全局作用域（全局执行上下文变量对象），在查找函数/方法/给定值时从顶层往下查找，找不到会报引用错误。

   ❓作用域的创建过程？
   在执行 js 代码时，会根据用户环境创建全局上下文，在函数被调用时，创建函数执行上下文，每个下下文包括三部分：

   - 变量对象：用于存储变量、函数、参数等信息
   - 作用域链：用于解析变量、函数的访问权限
   - this 关键字的值
     在执行上下文创建完成后，js引擎会根据作用域链的规则，将当前执行上下文中的变量对象添加到作用域链的顶端。

   ❓怎么判断 this
   一般来说谁调用 this 就指向谁
   经过一些方法，可以改变 this 指向，如 `call bind apply`，同时还有 `with`方法
6. 事件循环与消息队列

   1. 什么是
   2. node环境与浏览器环境的不同
7. 什么是 Promise
   Promise 是JS中的异步实现方式之一，通常叫做微任务。我们可以创建一个 Promise，把要执行的任务传递给他，其中的逻辑我们自己处理，只要在任务完成或失败时调用其提供的对应的回调函数，就可以改变 Promise 实例的状态；同时 Promise 的状态改变是不可逆的，只能从未完成到完成，完成分为成功和失败。
   同时，Promise 支持链式调用，实例提供 then 方法返回任务结束的结果，可以在任务结束后拿到结果进行后续操作，这样的调用方式优于多层的回调函数，这也是他取代使用回调完成异步操作的原因。

   ❓Promise怎么处理运行时错误呢？
   在异步中不能简单的使用 `try catch`，因为 `try catch`是同步执行的，而异步任务的执行时机在他之后，也就是说 `try catch`的调用栈完成且推出后才开始执行异步任务，此时在异步任务中抛出的错误不会被捕获；Promise 实例上提供了 `catch`方法来捕获 Promise 执行过程中的异常，当错误发生时，第一个 `catch`之前的所有 `then`都会被跳过，错误被处理后的 `then`可以正常执行

   ❓Promise 还有哪些方法？
   Primise 还有 `all race `等方法用来调度多个 Promise 实例的执行

   ❓await async 怎么调度 Promise
   在多种语言中都有这两个关键字，一般代表协程，js 中 await 与 async 也是类似的原理，使用生成器来调度多个异步任务，使其执行时机变为顺序的同步执行

   ❓什么是生成器
   Generator 也是一种异步解决方案，同样在多种语言中都存在，通常与迭代器、协程密切相关。在JS中，生成器可以看做是一个状态机，通过 `yield`定义每个状态阶段或执行阶段，在生成器函数执行时，会在 `yield`处暂停，并返回表达式的结果，将结果交给用户处理，这样，用户通过定义函数的执行阶段就能完全掌握每个阶段的执行和结果。
8. JS 有哪些模块化规范
   IIFE、CMD、AMD、ESM
   CMD 是 node 环境中的规范，不能在浏览器中使用，他通过 `require`引入模块，`exports`导出模块
   在导入模块时，会先寻找缓存，没有缓存则去找对应的脚本文件，然后执行脚本，将脚本中的 `module.exports`作为引入值，注意，这时的引入如同变量赋值，是一个引用，当你修改引入的基本类型时，其他模块中的引用是不会修改的
   CMD 的循环引入：在代码执行时，是按行执行的，当遇到引入其他模块时，会转手执行引入的模块的代码，如果在这个模块中碰到之前的模块，如果这个模块执行完成过，就是正常的模块，如果未执行完成（也就是循环引入的情况），那么这个模块的 `module.exports`就是未赋值的状态
   ESM 是ES6 的规范，现被浏览器支持，浏览器遇到 `import`会请求对应文件然后执行。
   ESM 会在代码解析阶段解析所有模块，因此一般要求 `import`写在脚本开头，就算不在开头也会被优先执行
   碰到 `import`时，回去加载并执行对应的脚本，然后再执行原来脚本 `import`语句之后的代码
   `export`语句声明的变量存在提升，如同函数提升、变量提升一样，在代码执行之前都完成定义
   他的循环依赖于CMD稍有不同，因为 `export`也是在解析过程中完成的，所以能够获取到导出变量的定义，但是没有值，但是像函数声明这种被同时提前的却能正常获取
   于CMD的另一个巨大区别是，ESM引入的所有值都是一个引用，值得更改在所有引入他的模块中是同步的，且不能再为引入变量关键字赋值
   为了解决动态导入问题，提供了 `import()`，他可以写在代码的任何地方，返回 Promise，他的引入不存在静态链接，即不同模块间的引入是独立的
9. requestAnimationFrame和requestIdleCallback


## 样式
1. css3特性中的`transform：translateZ(0)`有什么作用
2. width 百分比的基准元素是什么
3. willchange
## 浏览器

1. 浏览器的渲染流程
2. 哪些行为会阻塞渲染
3. 怎么统计拿到资源到页面渲染的时间
4. 浏览器有哪些线程和进程

## 框架

### vue

1. vue 的虚拟 DOM 与 react 有何不同
2. vue3有哪些优化
3. 节点 key 的作用

### react

#### 基本
1. 什么是 hook
2. hook 的优缺点
3. 一些内置 hook 的实现原理
4. 有哪些自定义 hook
5. 什么是僵尸children  [Redux 中过时的 props 和僵尸子节点](https://juejin.cn/post/6850418112991330318)
6. `setState`的同步异步问题
7. 重复调用 `setState` 会发生什么
8. `useEffect()`会有内存泄漏吗?

#### 原理相关
1. react18的总体流程
2. 什么是调度器、协调器、渲染器
3. 什么是时间切片原理
4. 为什么调度器使用`MessageChannel`而不是其他方法
5. 调度器任务优先级怎么做的
6. 什么是 diff
7. key 的作用
8. key设置为index的效果
9. 什么是异步可中断更新，怎么实现的
10. 什么是可中断渲染(同上)
11. 什么是`fiber`架构

### angular

## 工程化
1. HMR 原理

## 优化

1. SPA 首屏优化

## 代码

## 项目问题
1. vite 打包会将公共代码放到组件代码里，导致懒加载组件未加载时其他组件不能使用公共部分代码
2. build 后的koa ctx 接收formdata时，参数字段值会变为数组，导致开发与生产环境行为不一致

## 设计
1. 非同域的单点登录系统设计