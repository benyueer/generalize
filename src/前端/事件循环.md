# 事件循环

## 浏览器事件循环
浏览器环境中的 JavaScript 是运行在浏览器端，它的 eventLoop依赖是浏览器各个线程去处理「GUI 渲染线程、JavaScript引擎线程、定时触发器线程、事件触发线程、异步http请求线程」，协调事件队列(宏和微)来实现异步，代码的原地只是注册了函数，等程序处理完即可输出结果。


在浏览器的一个页面中，浏览器在调度页面的渲染、代码执行和其他事件触发时，可以看做是单线程的，当众多的任务需要执行时，需要一个合理的方式进行调度
于是就有了事件循环与消息队列
他们的逻辑是：所有的任务不断的加入到队列中，事件循环机制则不停的从队列中取出任务执行
任务又分为两种：
- 宏任务：文件 I/O , setTimeout, setInterval, 当前 script， 渲染事件(比如解析 DOM，计算布局，绘制)，网络请求完成
- 微任务：Promise MutationObserver ，Object.observe

在每次循环时，取出一个宏任务，执行完宏任务后，检查微任务，在执行过程中如果产生其他的宏任务和微任务，则新的宏任务会加到队列之后，微任务则会在本轮执行时继续执行，直到没有微任务后才会取出下一个宏任务

## 注意
- 事件循环由js引擎来调度和执行，队列中的js无关任务（如网络、定时器、渲染等）由js线程通知浏览器服务实现
- async 函数中的 await 之前的代码以及Promise定义中的代码是同步代码


## Node 的事件循环
Node.js 使用与浏览器中的 JavaScript 引擎不同的事件循环模型，称为 Node 的事件循环（Event Loop）。

Node.js 中的事件循环基于 libuv 库实现，它提供了跨平台的异步 I/O 和事件驱动的功能。Node 的事件循环主要用于处理非阻塞 I/O 操作，例如文件读写、网络请求等，以及处理定时器和事件回调。

Node 的事件循环模型包含以下几个阶段：

1. Timers 阶段（Timers Phase）：处理定时器的回调函数（setTimeout、setInterval 等）。

2. I/O 阶段（I/O Phase）：执行非阻塞的 I/O 操作的回调函数，例如文件 I/O、网络 I/O。

3. Idle、Prepare 阶段：在这两个阶段中，Node 内部做一些准备工作。

4. Poll 阶段（Poll Phase）：等待新的 I/O 事件，如果没有其他任务需要处理，则在此阶段阻塞等待。

5. Check 阶段（Check Phase）：执行 setImmediate() 设定的回调函数。

6. Close Callbacks 阶段：处理关闭的回调函数，例如 socket.on('close', ...)。

事件循环的执行顺序是按照上述阶段的顺序进行的。在每个阶段，事件循环会检查相应的任务队列，执行队列中的任务。如果某个阶段的任务队列为空，事件循环会继续下一个阶段。

需要注意的是，Node.js 中的事件循环是单线程的，但通过异步操作和回调函数，可以实现非阻塞的 I/O 处理和并发执行。这使得 Node.js 能够高效处理大量的并发请求，并具有良好的可扩展性。